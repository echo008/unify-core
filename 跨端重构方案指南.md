# 统御 (Unify) - Kotlin Multiplatform Compose 跨端架构设计方案

## 项目概述

**统御 (Unify)** 是一个基于 Kotlin Multiplatform + Compose 的现代化跨端开发解决方案，深度整合 JetBrains Compose Multiplatform 和腾讯 KuiklyUI 的最佳实践。通过统一的代码架构和组件体系，实现真正的"一套代码，统御全端"。

### 核心优势
- **100% 原生 KMP Compose 语法**：摒弃 DSL 转换，直接使用 Compose 原生 API
- **全平台统一架构**：共享业务逻辑，平台特定实现通过 expect/actual 机制
- **高性能渲染**：各平台使用原生渲染引擎，性能媲美原生应用
- **现代化开发体验**：完整的类型安全、编译时检查和 IDE 支持

### 目标平台支持
- **Android** (原生 Compose)
- **iOS** (Compose Multiplatform) 
- **HarmonyOS** (基于 KuiklyUI 方案)
- **Web (H5)** (Compose for Web + Kotlin/Wasm)
- **微信小程序** (通过 JS 桥接层)
- **其他小程序** (支付宝、百度、字节跳动等)
- **Electron** (基于 Web 版本)

## 一、整体架构设计

### 1.1 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (App Layer)                        │
├─────────────────────────────────────────────────────────────┤
│                  Compose UI 层 (UI Layer)                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Android   │ │     iOS     │ │  HarmonyOS  │           │
│  │   Compose   │ │   Compose   │ │   Compose   │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │    Web      │ │  MiniApps   │ │  Electron   │           │
│  │   Compose   │ │   Bridge    │ │    Web      │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                共享业务逻辑层 (Shared Logic)                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │  ViewModel  │ │ Repository  │ │   UseCase   │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                平台抽象层 (Platform Layer)                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Network   │ │   Storage   │ │   System    │           │
│  │   Service   │ │   Service   │ │   Service   │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                平台实现层 (Platform Impl)                    │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │androidMain  │ │  iosMain    │ │  jsMain     │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 项目结构

```kotlin
unify-kmp/
├── shared/
│   ├── commonMain/kotlin/
│   │   ├── ui/
│   │   │   ├── components/     // 通用 Compose 组件
│   │   │   ├── theme/          // 主题系统
│   │   │   ├── navigation/     // 导航系统
│   │   │   └── screens/        // 页面组件
│   │   ├── domain/
│   │   │   ├── model/          // 数据模型
│   │   │   ├── repository/     // 仓库接口
│   │   │   └── usecase/        // 业务用例
│   │   ├── data/
│   │   │   ├── remote/         // 网络数据源
│   │   │   ├── local/          // 本地数据源
│   │   │   └── repository/     // 仓库实现
│   │   └── platform/           // 平台抽象
│   ├── androidMain/
│   ├── iosMain/
│   ├── jsMain/
│   └── ohosMain/               // HarmonyOS 支持
├── androidApp/
├── iosApp/
├── webApp/
├── miniAppBridge/              // 小程序桥接层
├── electronApp/
└── build-logic/                // 构建逻辑
```

## 二、核心技术方案

### 2.1 依赖配置

### 2.1.1 根目录构建配置

```kotlin
// build.gradle.kts (项目根目录)
plugins {
    alias(libs.plugins.kotlin.multiplatform) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.android.library) apply false
    alias(libs.plugins.compose.multiplatform) apply false
    alias(libs.plugins.kotlin.serialization) apply false
}

allprojects {
    repositories {
        google()
        mavenCentral()
        maven("https://maven.pkg.jetbrains.space/public/p/compose/dev")
        // KuiklyUI 仓库
        maven {
            url = uri("https://mirrors.tencent.com/repository/maven/kuikly-public/")
        }
    }
}
```

```kotlin
// gradle/libs.versions.toml
[versions]
kotlin = "2.0.21"
compose = "1.7.0"
ktor = "2.3.7"
sqldelight = "2.0.1"
koin = "3.5.3"
navigation = "2.7.0-alpha07"
lifecycle = "2.8.0"
kuikly = "1.0.0"

[libraries]
kotlin-test = { module = "org.jetbrains.kotlin:kotlin-test", version.ref = "kotlin" }
ktor-client-core = { module = "io.ktor:ktor-client-core", version.ref = "ktor" }
ktor-client-android = { module = "io.ktor:ktor-client-android", version.ref = "ktor" }
ktor-client-darwin = { module = "io.ktor:ktor-client-darwin", version.ref = "ktor" }
ktor-client-js = { module = "io.ktor:ktor-client-js", version.ref = "ktor" }
ktor-client-cio = { module = "io.ktor:ktor-client-cio", version.ref = "ktor" }
ktor-serialization = { module = "io.ktor:ktor-serialization-kotlinx-json", version.ref = "ktor" }
ktor-content-negotiation = { module = "io.ktor:ktor-client-content-negotiation", version.ref = "ktor" }
sqldelight-runtime = { module = "app.cash.sqldelight:runtime", version.ref = "sqldelight" }
sqldelight-android = { module = "app.cash.sqldelight:android-driver", version.ref = "sqldelight" }
sqldelight-native = { module = "app.cash.sqldelight:native-driver", version.ref = "sqldelight" }
sqldelight-web = { module = "app.cash.sqldelight:web-driver", version.ref = "sqldelight" }
sqldelight-coroutines = { module = "app.cash.sqldelight:coroutines-extensions", version.ref = "sqldelight" }
koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }
koin-compose = { module = "io.insert-koin:koin-compose", version = "1.1.2" }
navigation-compose = { module = "org.jetbrains.androidx.navigation:navigation-compose", version.ref = "navigation" }
lifecycle-viewmodel = { module = "org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycle" }
kuikly-compose = { module = "com.tencent.kuikly:kuikly-compose", version.ref = "kuikly" }
kuikly-runtime = { module = "com.tencent.kuikly:kuikly-runtime", version.ref = "kuikly" }

[plugins]
kotlin-multiplatform = { id = "org.jetbrains.kotlin.multiplatform", version.ref = "kotlin" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
android-application = { id = "com.android.application", version = "8.2.2" }
android-library = { id = "com.android.library", version = "8.2.2" }
compose-multiplatform = { id = "org.jetbrains.compose", version.ref = "compose" }
kotlin-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
sqldelight = { id = "app.cash.sqldelight", version.ref = "sqldelight" }
```

### 2.1.2 共享模块构建配置

```kotlin
// shared/build.gradle.kts
plugins {
    alias(libs.plugins.kotlin.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.compose.multiplatform)
    alias(libs.plugins.kotlin.serialization)
    alias(libs.plugins.sqldelight)
}

kotlin {
    androidTarget {
        compilations.all {
            kotlinOptions {
                jvmTarget = "1.8"
            }
        }
    }
    
    listOf(iosX64(), iosArm64(), iosSimulatorArm64()).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "UnifyKmp"
            isStatic = true
        }
    }
    
    js(IR) {
        browser()
        binaries.executable()
    }
    
    // HarmonyOS 支持 - 基于 KuiklyUI 的 Kotlin/Native 配置
    val ohosArm64 = linuxArm64("ohosArm64") {
        binaries {
            executable {
                entryPoint = "main"
            }
            sharedLib {
                baseName = "unify-kmp"
            }
        }
        compilations.getByName("main") {
            cinterops {
                val harmonyos by creating {
                    defFile(project.file("src/ohosMain/cinterop/harmonyos.def"))
                    packageName("harmonyos")
                }
            }
        }
    }
    
    wasmJs {
        browser()
        binaries.executable()
    }
    
    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material3)
            implementation(compose.ui)
            implementation(compose.components.resources)
            
            // 网络
            implementation("io.ktor:ktor-client-core:2.3.7")
            implementation("io.ktor:ktor-client-content-negotiation:2.3.7")
            implementation("io.ktor:ktor-serialization-kotlinx-json:2.3.7")
            
            // 数据库
            implementation("app.cash.sqldelight:runtime:2.0.1")
            implementation("app.cash.sqldelight:coroutines-extensions:2.0.1")
            
            // 依赖注入
            implementation("io.insert-koin:koin-core:3.5.3")
            implementation("io.insert-koin:koin-compose:1.1.2")
            
            // 导航
            implementation("org.jetbrains.androidx.navigation:navigation-compose:2.7.0-alpha07")
            
            // 状态管理
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.0")
        }
        
        androidMain.dependencies {
            implementation(compose.preview)
            implementation("io.ktor:ktor-client-android:2.3.7")
            implementation("app.cash.sqldelight:android-driver:2.0.1")
        }
        
        iosMain.dependencies {
            implementation("io.ktor:ktor-client-darwin:2.3.7")
            implementation("app.cash.sqldelight:native-driver:2.0.1")
        }
        
        jsMain.dependencies {
            implementation(compose.html.core)
            implementation("io.ktor:ktor-client-js:2.3.7")
            implementation("app.cash.sqldelight:web-driver:2.0.1")
        }
        
        // HarmonyOS 依赖配置
        val ohosMain by getting {
            dependencies {
                // KuiklyUI 核心依赖
                implementation("com.tencent.kuikly:kuikly-compose:1.0.0")
                implementation("com.tencent.kuikly:kuikly-runtime:1.0.0")
                implementation("io.ktor:ktor-client-cio:2.3.7")
                implementation("app.cash.sqldelight:native-driver:2.0.1")
            }
        }
        
        // Wasm 依赖
        val wasmJsMain by getting {
            dependencies {
                implementation(compose.html.core)
                implementation("io.ktor:ktor-client-js:2.3.7")
            }
        }
    }
}
```

### 2.2 基础组件系统

#### 2.2.1 组件抽象定义

```kotlin
// shared/commonMain/kotlin/ui/components/UnifyComponent.kt
@Composable
expect fun UnifyView(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
)

@Composable
expect fun UnifyText(
    text: String,
    modifier: Modifier = Modifier,
    style: TextStyle = LocalTextStyle.current,
    color: Color = Color.Unspecified
)

@Composable
expect fun UnifyButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    content: @Composable RowScope.() -> Unit
)

@Composable
expect fun UnifyImage(
    src: String,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    contentScale: ContentScale = ContentScale.Fit
)

@Composable
expect fun UnifyInput(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    placeholder: String = "",
    enabled: Boolean = true
)
```

#### 2.2.2 HarmonyOS 平台实现

```kotlin
// shared/ohosMain/kotlin/ui/components/UnifyComponent.ohos.kt
// 基于 KuiklyUI 的 HarmonyOS 实现
@Composable
actual fun UnifyView(
    modifier: Modifier,
    content: @Composable () -> Unit
) {
    KuiklyBox(modifier = modifier) {
        content()
    }
}

@Composable
actual fun UnifyText(
    text: String,
    modifier: Modifier,
    style: TextStyle,
    color: Color
) {
    KuiklyText(
        text = text,
        modifier = modifier,
        style = style,
        color = color
    )
}

@Composable
actual fun UnifyButton(
    onClick: () -> Unit,
    modifier: Modifier,
    enabled: Boolean,
    content: @Composable RowScope.() -> Unit
) {
    KuiklyButton(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        content = content
    )
}

@Composable
actual fun UnifyImage(
    src: String,
    contentDescription: String?,
    modifier: Modifier,
    contentScale: ContentScale
) {
    KuiklyAsyncImage(
        model = src,
        contentDescription = contentDescription,
        modifier = modifier,
        contentScale = contentScale
    )
}

@Composable
actual fun UnifyInput(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier,
    placeholder: String,
    enabled: Boolean
) {
    KuiklyTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        placeholder = { KuiklyText(placeholder) },
        enabled = enabled
    )
}
```

#### 2.2.3 Android 平台实现

```kotlin
// shared/androidMain/kotlin/ui/components/UnifyComponent.android.kt
@Composable
actual fun UnifyView(
    modifier: Modifier,
    content: @Composable () -> Unit
) {
    Box(modifier = modifier) {
        content()
    }
}

@Composable
actual fun UnifyText(
    text: String,
    modifier: Modifier,
    style: TextStyle,
    color: Color
) {
    Text(
        text = text,
        modifier = modifier,
        style = style,
        color = color
    )
}

@Composable
actual fun UnifyButton(
    onClick: () -> Unit,
    modifier: Modifier,
    enabled: Boolean,
    content: @Composable RowScope.() -> Unit
) {
    Button(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        content = content
    )
}

@Composable
actual fun UnifyImage(
    src: String,
    contentDescription: String?,
    modifier: Modifier,
    contentScale: ContentScale
) {
    AsyncImage(
        model = src,
        contentDescription = contentDescription,
        modifier = modifier,
        contentScale = contentScale
    )
}

@Composable
actual fun UnifyInput(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier,
    placeholder: String,
    enabled: Boolean
) {
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        placeholder = { Text(placeholder) },
        enabled = enabled
    )
}
```

#### 2.2.4 iOS 平台实现

```kotlin
// shared/iosMain/kotlin/ui/components/UnifyComponent.ios.kt
@Composable
actual fun UnifyView(
    modifier: Modifier,
    content: @Composable () -> Unit
) {
    Box(modifier = modifier) {
        content()
    }
}

@Composable
actual fun UnifyText(
    text: String,
    modifier: Modifier,
    style: TextStyle,
    color: Color
) {
    Text(
        text = text,
        modifier = modifier,
        style = style,
        color = color
    )
}

@Composable
actual fun UnifyButton(
    onClick: () -> Unit,
    modifier: Modifier,
    enabled: Boolean,
    content: @Composable RowScope.() -> Unit
) {
    Button(
        onClick = onClick,
        modifier = modifier,
        enabled = enabled,
        content = content
    )
}

@Composable
actual fun UnifyImage(
    src: String,
    contentDescription: String?,
    modifier: Modifier,
    contentScale: ContentScale
) {
    AsyncImage(
        model = src,
        contentDescription = contentDescription,
        modifier = modifier,
        contentScale = contentScale
    )
}

@Composable
actual fun UnifyInput(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier,
    placeholder: String,
    enabled: Boolean
) {
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        placeholder = { Text(placeholder) },
        enabled = enabled
    )
}
```

#### 2.2.5 Web 平台实现

```kotlin
// shared/jsMain/kotlin/ui/components/UnifyComponent.js.kt
@Composable
actual fun UnifyView(
    modifier: Modifier,
    content: @Composable () -> Unit
) {
    Div(
        attrs = {
            style {
                display(DisplayStyle.Block)
            }
        }
    ) {
        content()
    }
}

@Composable
actual fun UnifyText(
    text: String,
    modifier: Modifier,
    style: TextStyle,
    color: Color
) {
    P(
        attrs = {
            style {
                color(color.toRgb())
                fontSize(style.fontSize.value.sp)
            }
        }
    ) {
        Text(text)
    }
}

@Composable
actual fun UnifyButton(
    onClick: () -> Unit,
    modifier: Modifier,
    enabled: Boolean,
    content: @Composable RowScope.() -> Unit
) {
    Button(
        attrs = {
            onClick { onClick() }
            disabled(!enabled)
            style {
                padding(8.px)
                borderRadius(4.px)
            }
        }
    ) {
        content()
    }
}

@Composable
actual fun UnifyImage(
    src: String,
    contentDescription: String?,
    modifier: Modifier,
    contentScale: ContentScale
) {
    Img(
        src = src,
        alt = contentDescription ?: "",
        attrs = {
            style {
                width(100.percent)
                height(100.percent)
                objectFit("cover")
            }
        }
    )
}

@Composable
actual fun UnifyInput(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier,
    placeholder: String,
    enabled: Boolean
) {
    Input(
        type = InputType.Text,
        attrs = {
            value(value)
            onInput { onValueChange(it.value) }
            placeholder(placeholder)
            disabled(!enabled)
            style {
                padding(8.px)
                border(1.px, LineStyle.Solid, Color.gray)
                borderRadius(4.px)
            }
        }
    )
}
```

### 2.3 状态管理系统

```kotlin
// shared/commonMain/kotlin/ui/base/BaseViewModel.kt
abstract class BaseViewModel : ViewModel() {
    protected val _uiState = MutableStateFlow(createInitialState())
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()
    
    protected val _uiEffect = MutableSharedFlow<UiEffect>()
    val uiEffect: SharedFlow<UiEffect> = _uiEffect.asSharedFlow()
    
    abstract fun createInitialState(): UiState
    
    protected fun updateState(reducer: UiState.() -> UiState) {
        _uiState.value = _uiState.value.reducer()
    }
    
    protected fun sendEffect(effect: UiEffect) {
        viewModelScope.launch {
            _uiEffect.emit(effect)
        }
    }
    
    abstract fun handleIntent(intent: UiIntent)
    
    // 错误处理机制
    protected fun handleError(error: Throwable) {
        viewModelScope.launch {
            val errorEffect = when (error) {
                is NetworkException -> UiEffect.ShowError("网络连接失败")
                is ValidationException -> UiEffect.ShowError(error.message ?: "数据验证失败")
                else -> UiEffect.ShowError("未知错误")
            }
            _uiEffect.emit(errorEffect)
        }
    }
    
    // 异步操作包装
    protected fun launchWithErrorHandling(
        block: suspend CoroutineScope.() -> Unit
    ) {
        viewModelScope.launch {
            try {
                block()
            } catch (e: Exception) {
                handleError(e)
            }
        }
    }
}

interface UiState
interface UiIntent  
interface UiEffect

// 异常类型定义
sealed class UnifyException(message: String) : Exception(message)
class NetworkException(message: String) : UnifyException(message)
class ValidationException(message: String) : UnifyException(message)
class PlatformException(message: String) : UnifyException(message)

// 通用 UI 效果
sealed class UiEffect {
    data class ShowError(val message: String) : UiEffect()
    data class ShowToast(val message: String) : UiEffect()
    data class Navigate(val route: String) : UiEffect()
    object Loading : UiEffect()
    object Idle : UiEffect()
}
```

### 2.4 小程序桥接层

#### 2.4.1 小程序适配器

#### 2.4.1 完整小程序桥接架构

```kotlin
// miniAppBridge/src/main/kotlin/core/MiniAppBridge.kt
class EnhancedMiniAppBridge {
    private val componentRegistry = mutableMapOf<String, ComponentRenderer>()
    private val stateManager = MiniAppStateManager()
    private val eventBus = MiniAppEventBus()
    private val styleConverter = StyleConverter()
    
    init {
        registerDefaultComponents()
    }
    
    private fun registerDefaultComponents() {
        componentRegistry["UnifyText"] = TextComponentRenderer()
        componentRegistry["UnifyButton"] = ButtonComponentRenderer()
        componentRegistry["UnifyImage"] = ImageComponentRenderer()
        componentRegistry["UnifyInput"] = InputComponentRenderer()
        componentRegistry["UnifyView"] = ViewComponentRenderer()
        componentRegistry["UnifyLazyColumn"] = LazyColumnComponentRenderer()
        componentRegistry["UnifyCard"] = CardComponentRenderer()
        componentRegistry["UnifyDialog"] = DialogComponentRenderer()
    }
    
    fun renderPage(pageData: PageRenderData): MiniAppPageResult {
        val wxml = generateWXML(pageData.componentTree)
        val wxss = generateWXSS(pageData.styles)
        val js = generateJS(pageData.logic)
        val json = generateJSON(pageData.config)
        
        return MiniAppPageResult(
            wxml = wxml,
            wxss = wxss,
            js = js,
            json = json
        )
    }
    
    private fun generateWXML(componentTree: ComponentNode): String {
        return buildString {
            appendLine("<view class='page-container'>")
            append(renderComponentTree(componentTree))
            appendLine("</view>")
        }
    }
    
    private fun renderComponentTree(node: ComponentNode): String {
        val renderer = componentRegistry[node.type] ?: return ""
        return renderer.render(node, this)
    }
    
    private fun generateWXSS(styles: Map<String, StyleProperties>): String {
        return buildString {
            appendLine(".page-container { padding: 20rpx; }")
            styles.forEach { (selector, properties) ->
                appendLine("$selector {")
                properties.forEach { (key, value) ->
                    appendLine("  ${styleConverter.convertProperty(key, value)};")
                }
                appendLine("}")
            }
        }
    }
    
    private fun generateJS(logic: PageLogic): String {
        return """
            const bridge = require('./bridge/wechat-bridge.js');
            
            Page({
                data: ${logic.initialData.toJson()},
                
                onLoad: function(options) {
                    bridge.onLoad(options);
                    this.initializeComponents();
                },
                
                onShow: function() {
                    bridge.onShow();
                },
                
                onHide: function() {
                    bridge.onHide();
                },
                
                onUnload: function() {
                    bridge.onUnload();
                },
                
                initializeComponents: function() {
                    ${logic.componentInitializers.joinToString("\n                    ")}
                },
                
                handleEvent: function(e) {
                    const { type, detail, currentTarget } = e;
                    bridge.handleComponentEvent(currentTarget.id, type, detail);
                },
                
                updateState: function(newState) {
                    this.setData(newState);
                }
            });
        """.trimIndent()
    }
    
    private fun generateJSON(config: PageConfig): String {
        return """
            {
                "navigationBarTitleText": "${config.title}",
                "backgroundColor": "${config.backgroundColor}",
                "navigationBarBackgroundColor": "${config.navigationBarColor}",
                "navigationBarTextStyle": "${config.navigationBarTextStyle}",
                "enablePullDownRefresh": ${config.enablePullDownRefresh},
                "usingComponents": {
                    ${config.customComponents.entries.joinToString(",\n                    ") { 
                        "\"${it.key}\": \"${it.value}\"" 
                    }}
                }
            }
        """.trimIndent()
    }
}

// 组件渲染器接口
interface ComponentRenderer {
    fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String
}

// 文本组件渲染器
class TextComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        val props = node.props
        return """
            <text 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}">
                ${props["text"] ?: ""}
            </text>
        """.trimIndent()
    }
}

// 按钮组件渲染器
class ButtonComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        val props = node.props
        return """
            <button 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}"
                disabled="${props["disabled"] ?: false}"
                bindtap="handleEvent">
                ${renderChildren(node.children, bridge)}
            </button>
        """.trimIndent()
    }
    
    private fun renderChildren(children: List<ComponentNode>, bridge: EnhancedMiniAppBridge): String {
        return children.joinToString("") { bridge.renderComponentTree(it) }
    }
}

// 图片组件渲染器
class ImageComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        val props = node.props
        return """
            <image 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}"
                src="${props["src"] ?: ""}"
                mode="${props["contentScale"] ?: "aspectFit"}"
                lazy-load="true"
                binderror="handleEvent"
                bindload="handleEvent" />
        """.trimIndent()
    }
}

// 输入框组件渲染器
class InputComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        val props = node.props
        return """
            <input 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}"
                value="${props["value"] ?: ""}"
                placeholder="${props["placeholder"] ?: ""}"
                disabled="${props["disabled"] ?: false}"
                bindinput="handleEvent"
                bindfocus="handleEvent"
                bindblur="handleEvent" />
        """.trimIndent()
    }
}

// 列表组件渲染器
class LazyColumnComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        val props = node.props
        return """
            <scroll-view 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}"
                scroll-y="true"
                enable-back-to-top="true"
                bindscrolltolower="handleEvent"
                bindscroll="handleEvent">
                ${renderChildren(node.children, bridge)}
            </scroll-view>
        """.trimIndent()
    }
    
    private fun renderChildren(children: List<ComponentNode>, bridge: EnhancedMiniAppBridge): String {
        return children.joinToString("") { bridge.renderComponentTree(it) }
    }
}

// 视图容器渲染器
class ViewComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        return """
            <view 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}"
                bindtap="handleEvent">
                ${renderChildren(node.children, bridge)}
            </view>
        """.trimIndent()
    }
    
    private fun renderChildren(children: List<ComponentNode>, bridge: EnhancedMiniAppBridge): String {
        return children.joinToString("") { bridge.renderComponentTree(it) }
    }
}

// 卡片组件渲染器
class CardComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        return """
            <view 
                class="card ${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}">
                ${renderChildren(node.children, bridge)}
            </view>
        """.trimIndent()
    }
    
    private fun renderChildren(children: List<ComponentNode>, bridge: EnhancedMiniAppBridge): String {
        return children.joinToString("") { bridge.renderComponentTree(it) }
    }
}

// 对话框组件渲染器
class DialogComponentRenderer : ComponentRenderer {
    override fun render(node: ComponentNode, bridge: EnhancedMiniAppBridge): String {
        val props = node.props
        return """
            <modal 
                class="${node.className}" 
                style="${node.inlineStyle}"
                data-component-id="${node.id}"
                show="${props["show"] ?: false}"
                bindcancel="handleEvent"
                bindconfirm="handleEvent">
                <view class="modal-content">
                    ${renderChildren(node.children, bridge)}
                </view>
            </modal>
        """.trimIndent()
    }
    
    private fun renderChildren(children: List<ComponentNode>, bridge: EnhancedMiniAppBridge): String {
        return children.joinToString("") { bridge.renderComponentTree(it) }
    }
}

// 数据类定义
data class ComponentNode(
    val id: String,
    val type: String,
    val props: Map<String, Any>,
    val children: List<ComponentNode>,
    val className: String = "",
    val inlineStyle: String = ""
)

data class PageRenderData(
    val componentTree: ComponentNode,
    val styles: Map<String, StyleProperties>,
    val logic: PageLogic,
    val config: PageConfig
)

data class MiniAppPageResult(
    val wxml: String,
    val wxss: String,
    val js: String,
    val json: String
)

data class PageLogic(
    val initialData: Map<String, Any>,
    val componentInitializers: List<String>
)

data class PageConfig(
    val title: String,
    val backgroundColor: String,
    val navigationBarColor: String,
    val navigationBarTextStyle: String,
    val enablePullDownRefresh: Boolean,
    val customComponents: Map<String, String>
)

typealias StyleProperties = Map<String, String>
```

#### 2.4.2 微信小程序 JavaScript 桥接实现

```javascript
// miniAppBridge/src/main/resources/bridge/wechat-bridge.js
class WeChatEnhancedBridge {
    constructor() {
        this.componentInstances = new Map();
        this.stateSubscriptions = new Map();
        this.kotlinRuntime = null;
        this.pageStack = [];
        this.eventQueue = [];
        this.isInitialized = false;
    }
    
    async initKotlinRuntime() {
        try {
            // 初始化 Kotlin/JS 运行时
            this.kotlinRuntime = await import('./kotlin-runtime.js');
            this.isInitialized = true;
            this.processEventQueue();
        } catch (error) {
            console.error('Failed to initialize Kotlin runtime:', error);
        }
    }
    
    onLoad(options) {
        console.log('Page loaded with options:', options);
        this.pageStack.push({
            route: getCurrentPages()[getCurrentPages().length - 1].route,
            options: options,
            timestamp: Date.now()
        });
        
        if (!this.isInitialized) {
            this.initKotlinRuntime();
        }
        
        // 触发页面加载事件
        this.emitEvent('page:load', { options });
    }
    
    onShow() {
        console.log('Page shown');
        this.emitEvent('page:show', {});
        
        // 恢复组件状态
        this.componentInstances.forEach((instance, componentId) => {
            if (instance.onShow) {
                instance.onShow();
            }
        });
    }
    
    onHide() {
        console.log('Page hidden');
        this.emitEvent('page:hide', {});
        
        // 暂停组件状态
        this.componentInstances.forEach((instance, componentId) => {
            if (instance.onHide) {
                instance.onHide();
            }
        });
    }
    
    onUnload() {
        console.log('Page unloaded');
        this.emitEvent('page:unload', {});
        
        // 清理资源
        this.componentInstances.clear();
        this.stateSubscriptions.clear();
        this.pageStack.pop();
    }
    
    handleComponentEvent(componentId, eventType, eventData) {
        console.log('Component event:', { componentId, eventType, eventData });
        
        const event = {
            componentId,
            type: eventType,
            data: eventData,
            timestamp: Date.now()
        };
        
        if (!this.isInitialized) {
            this.eventQueue.push(event);
            return;
        }
        
        try {
            // 调用 Kotlin 端事件处理
            if (this.kotlinRuntime && this.kotlinRuntime.handleEvent) {
                this.kotlinRuntime.handleEvent(event);
            }
            
            // 本地事件处理
            this.processLocalEvent(event);
        } catch (error) {
            console.error('Error handling component event:', error);
        }
    }
    
    processLocalEvent(event) {
        const { componentId, type, data } = event;
        
        switch (type) {
            case 'tap':
                this.handleTapEvent(componentId, data);
                break;
            case 'input':
                this.handleInputEvent(componentId, data);
                break;
            case 'scroll':
                this.handleScrollEvent(componentId, data);
                break;
            case 'load':
            case 'error':
                this.handleMediaEvent(componentId, type, data);
                break;
            default:
                console.log('Unhandled event type:', type);
        }
    }
    
    handleTapEvent(componentId, data) {
        // 处理点击事件
        this.emitEvent('component:tap', { componentId, data });
    }
    
    handleInputEvent(componentId, data) {
        // 处理输入事件
        const value = data.detail ? data.detail.value : data.value;
        this.updateComponentState(componentId, { value });
        this.emitEvent('component:input', { componentId, value });
    }
    
    handleScrollEvent(componentId, data) {
        // 处理滚动事件
        const scrollData = {
            scrollTop: data.detail.scrollTop,
            scrollLeft: data.detail.scrollLeft
        };
        this.emitEvent('component:scroll', { componentId, scrollData });
    }
    
    handleMediaEvent(componentId, type, data) {
        // 处理媒体加载事件
        this.emitEvent(`component:${type}`, { componentId, data });
    }
    
    updateComponentState(componentId, newState) {
        const instance = this.componentInstances.get(componentId);
        if (instance) {
            Object.assign(instance.state, newState);
            
            // 触发状态更新回调
            if (instance.onStateChange) {
                instance.onStateChange(newState);
            }
        }
        
        // 通知页面更新
        const currentPage = getCurrentPages()[getCurrentPages().length - 1];
        if (currentPage && currentPage.updateState) {
            currentPage.updateState({ [componentId]: newState });
        }
    }
    
    emitEvent(eventName, eventData) {
        // 事件发射器
        const event = {
            name: eventName,
            data: eventData,
            timestamp: Date.now()
        };
        
        console.log('Emitting event:', event);
        
        // 如果有 Kotlin 运行时，通知它
        if (this.kotlinRuntime && this.kotlinRuntime.onEvent) {
            this.kotlinRuntime.onEvent(event);
        }
    }
    
    processEventQueue() {
        // 处理队列中的事件
        while (this.eventQueue.length > 0) {
            const event = this.eventQueue.shift();
            this.handleComponentEvent(event.componentId, event.type, event.data);
        }
    }
    
    // 平台 API 适配
    showToast(options) {
        wx.showToast({
            title: options.title || '提示',
            icon: options.icon || 'none',
            duration: options.duration || 2000,
            mask: options.mask || false
        });
    }
    
    navigateTo(url) {
        wx.navigateTo({ url });
    }
    
    redirectTo(url) {
        wx.redirectTo({ url });
    }
    
    navigateBack(delta = 1) {
        wx.navigateBack({ delta });
    }
    
    async request(options) {
        return new Promise((resolve, reject) => {
            wx.request({
                ...options,
                success: resolve,
                fail: reject
            });
        });
    }
    
    async getStorage(key) {
        return new Promise((resolve, reject) => {
            wx.getStorage({
                key,
                success: (res) => resolve(res.data),
                fail: reject
            });
        });
    }
    
    async setStorage(key, data) {
        return new Promise((resolve, reject) => {
            wx.setStorage({
                key,
                data,
                success: resolve,
                fail: reject
            });
        });
    }
    
    getCurrentPage() {
        const pages = getCurrentPages();
        return pages[pages.length - 1];
    }
    
    getPageStack() {
        return [...this.pageStack];
    }
}

// 导出桥接实例
const bridge = new WeChatEnhancedBridge();

module.exports = {
    onLoad: bridge.onLoad.bind(bridge),
    onShow: bridge.onShow.bind(bridge),
    onHide: bridge.onHide.bind(bridge),
    onUnload: bridge.onUnload.bind(bridge),
    handleComponentEvent: bridge.handleComponentEvent.bind(bridge),
    updateComponentState: bridge.updateComponentState.bind(bridge),
    showToast: bridge.showToast.bind(bridge),
    navigateTo: bridge.navigateTo.bind(bridge),
    request: bridge.request.bind(bridge),
    getStorage: bridge.getStorage.bind(bridge),
    setStorage: bridge.setStorage.bind(bridge)
};
```

#### 2.4.3 样式转换器实现

```kotlin
// miniAppBridge/src/main/kotlin/style/StyleConverter.kt
class StyleConverter {
    private val propertyMap = mapOf(
        "width" to "width",
        "height" to "height",
        "padding" to "padding",
        "margin" to "margin",
        "backgroundColor" to "background-color",
        "color" to "color",
        "fontSize" to "font-size",
        "fontWeight" to "font-weight",
        "textAlign" to "text-align",
        "borderRadius" to "border-radius",
        "borderWidth" to "border-width",
        "borderColor" to "border-color",
        "display" to "display",
        "flexDirection" to "flex-direction",
        "justifyContent" to "justify-content",
        "alignItems" to "align-items",
        "position" to "position",
        "top" to "top",
        "left" to "left",
        "right" to "right",
        "bottom" to "bottom",
        "zIndex" to "z-index",
        "opacity" to "opacity",
        "overflow" to "overflow"
    )
    
    fun convertProperty(key: String, value: Any): String {
        val cssProperty = propertyMap[key] ?: key
        val cssValue = convertValue(key, value)
        return "$cssProperty: $cssValue"
    }
    
    private fun convertValue(key: String, value: Any): String {
        return when (key) {
            "width", "height", "padding", "margin" -> {
                convertSizeValue(value)
            }
            "fontSize" -> {
                convertFontSize(value)
            }
            "color", "backgroundColor", "borderColor" -> {
                convertColor(value)
            }
            "fontWeight" -> {
                convertFontWeight(value)
            }
            else -> value.toString()
        }
    }
    
    private fun convertSizeValue(value: Any): String {
        return when (value) {
            is Number -> "${value}rpx"
            is String -> {
                if (value.endsWith("dp") || value.endsWith("px")) {
                    "${value.removeSuffix("dp").removeSuffix("px")}rpx"
                } else {
                    value
                }
            }
            else -> value.toString()
        }
    }
    
    private fun convertFontSize(value: Any): String {
        return when (value) {
            is Number -> "${value}rpx"
            is String -> {
                when {
                    value.endsWith("sp") -> "${value.removeSuffix("sp")}rpx"
                    value.endsWith("dp") -> "${value.removeSuffix("dp")}rpx"
                    else -> value
                }
            }
            else -> value.toString()
        }
    }
    
    private fun convertColor(value: Any): String {
        return when (value) {
            is String -> {
                if (value.startsWith("#")) {
                    value
                } else {
                    "#$value"
                }
            }
            else -> value.toString()
        }
    }
    
    private fun convertFontWeight(value: Any): String {
        return when (value.toString().lowercase()) {
            "bold" -> "bold"
            "normal" -> "normal"
            "light" -> "300"
            "medium" -> "500"
            "semibold" -> "600"
            else -> value.toString()
        }
    }
}
```

### 2.5 平台特定 API 实现

#### 2.5.1 网络请求封装

```kotlin
// shared/commonMain/kotlin/platform/NetworkService.kt
expect class NetworkService {
    suspend fun get(url: String, headers: Map<String, String> = emptyMap()): NetworkResponse
    suspend fun post(url: String, body: String, headers: Map<String, String> = emptyMap()): NetworkResponse
    suspend fun put(url: String, body: String, headers: Map<String, String> = emptyMap()): NetworkResponse
    suspend fun delete(url: String, headers: Map<String, String> = emptyMap()): NetworkResponse
}

data class NetworkResponse(
    val status: Int,
    val body: String,
    val headers: Map<String, String>
)

// Android 实现
// shared/androidMain/kotlin/platform/NetworkService.android.kt
actual class NetworkService {
    private val client = HttpClient(Android) {
        install(ContentNegotiation) {
            json()
        }
    }
    
    actual suspend fun get(url: String, headers: Map<String, String>): NetworkResponse {
        val response = client.get(url) {
            headers.forEach { (key, value) -> header(key, value) }
        }
        return NetworkResponse(
            status = response.status.value,
            body = response.bodyAsText(),
            headers = response.headers.toMap()
        )
    }
    
    actual suspend fun post(url: String, body: String, headers: Map<String, String>): NetworkResponse {
        val response = client.post(url) {
            headers.forEach { (key, value) -> header(key, value) }
            setBody(body)
        }
        return NetworkResponse(
            status = response.status.value,
            body = response.bodyAsText(),
            headers = response.headers.toMap()
        )
    }
    
    actual suspend fun put(url: String, body: String, headers: Map<String, String>): NetworkResponse {
        val response = client.put(url) {
            headers.forEach { (key, value) -> header(key, value) }
            setBody(body)
        }
        return NetworkResponse(
            status = response.status.value,
            body = response.bodyAsText(),
            headers = response.headers.toMap()
        )
    }
    
    actual suspend fun delete(url: String, headers: Map<String, String>): NetworkResponse {
        val response = client.delete(url) {
            headers.forEach { (key, value) -> header(key, value) }
        }
        return NetworkResponse(
            status = response.status.value,
            body = response.bodyAsText(),
            headers = response.headers.toMap()
        )
    }
}

// HarmonyOS 实现
// shared/ohosMain/kotlin/platform/NetworkService.ohos.kt
actual class NetworkService {
    private val client = HttpClient(CIO) {
        install(ContentNegotiation) {
            json()
        }
    }
    
    actual suspend fun get(url: String, headers: Map<String, String>): NetworkResponse {
        // 使用 KuiklyUI 的网络封装
        return withContext(Dispatchers.IO) {
            val response = client.get(url) {
                headers.forEach { (key, value) -> header(key, value) }
            }
            NetworkResponse(
                status = response.status.value,
                body = response.bodyAsText(),
                headers = response.headers.toMap()
            )
        }
    }
    
    // 其他方法类似实现...
    actual suspend fun post(url: String, body: String, headers: Map<String, String>): NetworkResponse = TODO()
    actual suspend fun put(url: String, body: String, headers: Map<String, String>): NetworkResponse = TODO()
    actual suspend fun delete(url: String, headers: Map<String, String>): NetworkResponse = TODO()
}
```

#### 2.5.2 存储服务封装

```kotlin
// shared/commonMain/kotlin/platform/StorageService.kt
expect class StorageService {
    suspend fun getString(key: String): String?
    suspend fun setString(key: String, value: String)
    suspend fun getInt(key: String): Int?
    suspend fun setInt(key: String, value: Int)
    suspend fun getBoolean(key: String): Boolean?
    suspend fun setBoolean(key: String, value: Boolean)
    suspend fun remove(key: String)
    suspend fun clear()
}

// Android 实现
// shared/androidMain/kotlin/platform/StorageService.android.kt
actual class StorageService(private val context: Context) {
    private val prefs = context.getSharedPreferences("unify_prefs", Context.MODE_PRIVATE)
    
    actual suspend fun getString(key: String): String? {
        return prefs.getString(key, null)
    }
    
    actual suspend fun setString(key: String, value: String) {
        prefs.edit().putString(key, value).apply()
    }
    
    actual suspend fun getInt(key: String): Int? {
        return if (prefs.contains(key)) prefs.getInt(key, 0) else null
    }
    
    actual suspend fun setInt(key: String, value: Int) {
        prefs.edit().putInt(key, value).apply()
    }
    
    actual suspend fun getBoolean(key: String): Boolean? {
        return if (prefs.contains(key)) prefs.getBoolean(key, false) else null
    }
    
    actual suspend fun setBoolean(key: String, value: Boolean) {
        prefs.edit().putBoolean(key, value).apply()
    }
    
    actual suspend fun remove(key: String) {
        prefs.edit().remove(key).apply()
    }
    
    actual suspend fun clear() {
        prefs.edit().clear().apply()
    }
}
```

### 2.6 性能优化方案

#### 2.6.1 Compose 性能优化

```kotlin
// shared/commonMain/kotlin/ui/performance/PerformanceOptimization.kt

// 1. 组件懒加载
@Composable
fun LazyLoadComponent(
    isVisible: Boolean,
    content: @Composable () -> Unit
) {
    if (isVisible) {
        content()
    } else {
        // 占位符
        Box(modifier = Modifier.size(0.dp))
    }
}

// 2. 图片预加载管理
@Composable
fun PreloadImageManager(
    imageUrls: List<String>,
    preloadCount: Int = 3
) {
    LaunchedEffect(imageUrls) {
        imageUrls.take(preloadCount).forEach { url ->
            // 预加载图片
            preloadImage(url)
        }
    }
}

suspend fun preloadImage(url: String) {
    // 平台特定的图片预加载实现
}

// 3. 状态优化
@Composable
fun OptimizedStateComponent(
    data: List<String>
) {
    // 使用 derivedStateOf 减少不必要的重组
    val filteredData by remember {
        derivedStateOf {
            data.filter { it.isNotBlank() }
        }
    }
    
    LazyColumn {
        items(filteredData) { item ->
            Text(item)
        }
    }
}

// 4. 列表性能优化
val optimizedFlingBehavior = rememberScrollableDefaults().flingBehavior

@Composable
fun OptimizedLazyColumn(
    items: List<Any>,
    content: @Composable LazyItemScope.(Any) -> Unit
) {
    LazyColumn(
        flingBehavior = optimizedFlingBehavior,
        contentPadding = PaddingValues(vertical = 8.dp)
    ) {
        items(
            items = items,
            key = { it.hashCode() } // 使用稳定的 key
        ) { item ->
            content(item)
        }
    }
}
```

#### 2.6.2 内存管理优化

```kotlin
// shared/commonMain/kotlin/cache/LRUCache.kt
class LRUCache<K, V>(private val maxSize: Int) {
    private val cache = linkedMapOf<K, V>()
    
    fun get(key: K): V? {
        val value = cache.remove(key)
        return if (value != null) {
            cache[key] = value
            value
        } else null
    }
    
    fun put(key: K, value: V) {
        if (cache.containsKey(key)) {
            cache.remove(key)
        } else if (cache.size >= maxSize) {
            val firstKey = cache.keys.first()
            cache.remove(firstKey)
        }
        cache[key] = value
    }
    
    fun clear() {
        cache.clear()
    }
    
    fun size(): Int = cache.size
}

// 内存监控
@Composable
fun MemoryMonitor() {
    val memoryInfo = remember { mutableStateOf(MemoryInfo()) }
    
    LaunchedEffect(Unit) {
        while (true) {
            delay(5000) // 每5秒检查一次
            memoryInfo.value = getCurrentMemoryInfo()
        }
    }
    
    // 内存使用超过阈值时清理缓存
    LaunchedEffect(memoryInfo.value) {
        if (memoryInfo.value.usagePercentage > 0.8f) {
            clearCaches()
        }
    }
}

data class MemoryInfo(
    val totalMemory: Long = 0,
    val usedMemory: Long = 0,
    val usagePercentage: Float = 0f
)

expect fun getCurrentMemoryInfo(): MemoryInfo
expect fun clearCaches()
```

#### 2.4.3 状态管理和事件处理

```kotlin
// miniAppBridge/src/main/kotlin/state/MiniAppStateManager.kt
class MiniAppStateManager {
    private val stateStore = mutableMapOf<String, Any>()
    private val listeners = mutableMapOf<String, MutableList<(Any) -> Unit>>()
    
    fun setState(key: String, value: Any) {
        stateStore[key] = value
        notifyListeners(key, value)
    }
    
    fun getState(key: String): Any? = stateStore[key]
    
    fun subscribe(key: String, listener: (Any) -> Unit) {
        listeners.getOrPut(key) { mutableListOf() }.add(listener)
    }
    
    private fun notifyListeners(key: String, value: Any) {
        listeners[key]?.forEach { it(value) }
    }
}
```

### 2.7 动态化能力实现

#### 2.7.1 热更新机制

```kotlin
// shared/commonMain/kotlin/dynamic/HotUpdateManager.kt
class HotUpdateManager {
    private val configCache = LRUCache<String, ComponentConfig>(100)
    private val componentFactory = ComponentFactory()
    
    suspend fun checkForUpdates(): UpdateResult {
        return try {
            val response = NetworkService().get("/api/updates/check")
            if (response.status == 200) {
                val updateInfo = Json.decodeFromString<UpdateInfo>(response.body)
                UpdateResult.Success(updateInfo)
            } else {
                UpdateResult.NoUpdate
            }
        } catch (e: Exception) {
            UpdateResult.Error(e.message ?: "Unknown error")
        }
    }
    
    suspend fun downloadUpdate(updateInfo: UpdateInfo): Boolean {
        return try {
            val response = NetworkService().get(updateInfo.downloadUrl)
            if (response.status == 200) {
                val configData = Json.decodeFromString<Map<String, ComponentConfig>>(response.body)
                configData.forEach { (key, config) ->
                    configCache.put(key, config)
                }
                true
            } else false
        } catch (e: Exception) {
            false
        }
    }
    
    @Composable
    fun DynamicComponent(
        componentId: String,
        fallbackContent: @Composable () -> Unit = {}
    ) {
        val config = configCache.get(componentId)
        
        if (config != null) {
            componentFactory.CreateComponent(config)
        } else {
            fallbackContent()
        }
    }
}

data class UpdateInfo(
    val version: String,
    val downloadUrl: String,
    val components: List<String>
)

sealed class UpdateResult {
    data class Success(val updateInfo: UpdateInfo) : UpdateResult()
    object NoUpdate : UpdateResult()
    data class Error(val message: String) : UpdateResult()
}

data class ComponentConfig(
    val type: String,
    val props: Map<String, Any>,
    val style: Map<String, String>,
    val children: List<ComponentConfig> = emptyList()
)
```

#### 2.7.2 配置驱动的 UI 渲染

```kotlin
// shared/commonMain/kotlin/dynamic/ConfigDrivenUI.kt
class ComponentFactory {
    @Composable
    fun CreateComponent(config: ComponentConfig) {
        when (config.type) {
            "text" -> {
                UnifyText(
                    text = config.props["text"] as? String ?: "",
                    modifier = Modifier.applyStyle(config.style)
                )
            }
            "button" -> {
                UnifyButton(
                    onClick = { /* 从配置中获取事件处理 */ },
                    modifier = Modifier.applyStyle(config.style)
                ) {
                    config.children.forEach { childConfig ->
                        CreateComponent(childConfig)
                    }
                }
            }
            "image" -> {
                UnifyImage(
                    src = config.props["src"] as? String ?: "",
                    contentDescription = config.props["alt"] as? String,
                    modifier = Modifier.applyStyle(config.style)
                )
            }
            "view" -> {
                UnifyView(
                    modifier = Modifier.applyStyle(config.style)
                ) {
                    config.children.forEach { childConfig ->
                        CreateComponent(childConfig)
                    }
                }
            }
            else -> {
                // 未知组件类型，显示错误信息
                Text("未知组件: ${config.type}")
            }
        }
    }
}

fun Modifier.applyStyle(style: Map<String, String>): Modifier {
    var modifier = this
    
    style.forEach { (key, value) ->
        modifier = when (key) {
            "width" -> modifier.width(value.toDp())
            "height" -> modifier.height(value.toDp())
            "padding" -> modifier.padding(value.toDp())
            "backgroundColor" -> modifier.background(Color(value.toColorInt()))
            else -> modifier
        }
    }
    
    return modifier
}

private fun String.toDp(): Dp {
    return this.removeSuffix("dp").toFloatOrNull()?.dp ?: 0.dp
}

private fun String.toColorInt(): Long {
    return this.removePrefix("#").toLongOrNull(16) ?: 0xFF000000
}
```

## 三、迁移策略

### 3.1 迁移阶段规划

#### 阶段一：基础架构搭建 (2-3周)
1. **项目结构初始化**
   - 创建 KMP 项目结构
   - 配置 Gradle 构建脚本
   - 设置各平台目标

2. **核心模块开发**
   - 实现基础组件系统
   - 建立状态管理框架
   - 创建导航系统

#### 阶段二：组件迁移 (3-4周)
1. **基础组件迁移**
   - View → UnifyView
   - Text → UnifyText
   - Button → UnifyButton
   - Image → UnifyImage
   - Input → UnifyInput

2. **复杂组件迁移**
   - List → LazyColumn/LazyRow
   - ScrollView → LazyColumn with scrolling
   - Picker → Custom Compose Picker
   - Dialog → Compose Dialog

#### 阶段三：业务逻辑迁移 (4-5周)
1. **页面迁移**
   - 将 CML 页面转换为 Compose Screen
   - 迁移页面状态管理
   - 适配导航逻辑

2. **API 集成**
   - 网络请求迁移到 Ktor
   - 数据存储迁移到 SQLDelight
   - 平台 API 封装

#### 阶段四：小程序适配 (2-3周)
1. **桥接层开发**
   - 微信小程序桥接
   - 支付宝小程序桥接
   - 其他小程序平台桥接

2. **组件映射**
   - Compose 组件到小程序组件映射
   - 样式转换系统
   - 事件处理机制

#### 阶段五：测试与优化 (2-3周)
1. **功能测试**
   - 各平台功能一致性测试
   - 性能基准测试
   - 兼容性测试

2. **优化调整**
   - 性能优化
   - 内存优化
   - 包体积优化

## 四、详细技术实现方案

### 4.1 KuiklyUI 架构深度集成

#### 4.1.1 ComposeContainer 基础架构

```kotlin
abstract class UnifyComposeContainer : ComposeContainer() {
    
    override fun willInit() {
        super.willInit()
        setupUnifyTheme()
        initializeViewModel()
        setContent {
            UnifyTheme {
                CompositionLocalProvider(
                    LocalUnifyNavController provides rememberNavController(),
                    LocalUnifyViewModel provides getViewModel()
                ) {
                    Content()
                }
            }
        }
    }
    
    @Composable
    abstract fun Content()
    
    abstract fun setupUnifyTheme()
    abstract fun initializeViewModel()
    abstract fun getViewModel(): BaseViewModel
}

// 页面实现示例
@Page("home")
internal class HomePage : UnifyComposeContainer() {
    
    private lateinit var viewModel: HomeViewModel
    
    override fun setupUnifyTheme() {
        // 设置主题配置
    }
    
    override fun initializeViewModel() {
        viewModel = koinInject()
    }
    
    override fun getViewModel(): BaseViewModel = viewModel
    
    @Composable
    override fun Content() {
        val uiState by viewModel.uiState.collectAsState()
        val navController = LocalUnifyNavController.current
        
        HomeScreen(
            uiState = uiState,
            onIntent = viewModel::handleIntent,
            onNavigate = { destination ->
                navController.navigate(destination)
            }
        )
    }
}

// shared/commonMain/kotlin/ui/components/UnifyComponents.kt

// 基于 KuiklyUI 的完整组件支持
@Composable
expect fun UnifyText(
    text: String,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    onTextLayout: (TextLayoutResult) -> Unit = {},
    style: TextStyle = LocalTextStyle.current
)

@Composable
expect fun UnifyButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.shape,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    elevation: ButtonElevation? = ButtonDefaults.buttonElevation(),
    border: BorderStroke? = null,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    content: @Composable RowScope.() -> Unit
)

@Composable
expect fun UnifyLazyColumn(
    modifier: Modifier = Modifier,
    state: LazyListState = rememberLazyListState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,
    horizontalAlignment: Alignment.Horizontal = Alignment.Start,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyListScope.() -> Unit
)

@Composable
expect fun UnifyCard(
    modifier: Modifier = Modifier,
    shape: Shape = CardDefaults.shape,
    colors: CardColors = CardDefaults.cardColors(),
    elevation: CardElevation = CardDefaults.cardElevation(),
    border: BorderStroke? = null,
    content: @Composable ColumnScope.() -> Unit
)

@Composable
expect fun UnifyDialog(
    onDismissRequest: () -> Unit,
    modifier: Modifier = Modifier,
    properties: DialogProperties = DialogProperties(),
    content: @Composable () -> Unit
)

// shared/commonMain/kotlin/platform/HarmonyOSPlatformService.kt
actual class PlatformService {
    actual fun getPlatformName(): String = "HarmonyOS"
    
    actual suspend fun makeHttpRequest(url: String): String {
        // HarmonyOS 网络请求实现
        return withContext(Dispatchers.IO) {
            // 使用 HarmonyOS 原生网络 API
            ""
        }
    }
    
    actual suspend fun saveToStorage(key: String, value: String) {
        // HarmonyOS 存储实现
    }
    
    actual suspend fun getFromStorage(key: String): String? {
        // HarmonyOS 存储读取实现
        return null
    }
    
    actual fun showToast(message: String) {
        // HarmonyOS Toast 实现
    }
    
    actual fun vibrate(duration: Long) {
        // HarmonyOS 震动实现
    }
}

// miniAppBridge/src/main/kotlin/generator/MiniAppPageGenerator.kt
class MiniAppPageGenerator {
    
    fun generateWeChatPage(
        pageName: String,
        componentTree: ComponentNode,
        viewModel: BaseViewModel
    ): MiniAppPage {
        val wxml = generateWXML(componentTree)
        val wxss = generateWXSS(componentTree)
        val js = generateJS(pageName, viewModel)
        val json = generateJSON(pageName)
        
        return MiniAppPage(
            name = pageName,
            wxml = wxml,
            wxss = wxss,
            js = js,
            json = json
        )
    }
    
    private fun generateWXML(node: ComponentNode): String {
        return """
            <!--pages/$pageName/$pageName.wxml-->
            <view class="unify-root">
              ${renderComponentNode(node)}
            </view>
        """.trimIndent()
    }
    
    private fun generateWXSS(node: ComponentNode): String {
        return """
            /* pages/$pageName/$pageName.wxss */
            .unify-root {
              height: 100vh;
              display: flex;
              flex-direction: column;
            }
            
            ${generateComponentStyles(node)}
        """.trimIndent()
    }
    
    private fun generateJS(pageName: String, viewModel: BaseViewModel): String {
        return """
            // pages/$pageName/$pageName.js
            const { bridge } = require('../../utils/bridge.js');
            
            Page({
              data: {
                ${generateInitialData(viewModel)}
              },
              
              onLoad: function(options) {
                bridge.onLoad.call(this, options);
              },
              
              onShow: function() {
                bridge.onShow.call(this);
              },
              
              onHide: function() {
                bridge.onHide.call(this);
              },
              
              onUnload: function() {
                bridge.onUnload.call(this);
              },
              
              ${generateEventHandlers(viewModel)}
            });
        """.trimIndent()
    }
    
    private fun generateJSON(pageName: String): String {
        return """
            {
              "usingComponents": {},
              "navigationBarTitleText": "$pageName"
            }
        """.trimIndent()
    }
}

// shared/commonMain/kotlin/config/ConfigDrivenRenderer.kt
class ConfigDrivenRenderer {
    
    @Composable
    fun RenderFromConfig(config: UIConfig) {
        when (config.type) {
            UIType.PAGE -> RenderPage(config as PageConfig)
            UIType.COMPONENT -> RenderComponent(config as ComponentConfig)
            UIType.LAYOUT -> RenderLayout(config as LayoutConfig)
        }
    }
    
    @Composable
    private fun RenderPage(config: PageConfig) {
        UnifyTheme {
            Column(
                modifier = Modifier.fillMaxSize()
            ) {
                config.components.forEach { componentConfig ->
                    RenderComponent(componentConfig)
                }
            }
        }
    }
    
    @Composable
    private fun RenderComponent(config: ComponentConfig) {
        when (config.componentType) {
            "text" -> UnifyText(
                text = config.props["text"] as? String ?: "",
                color = Color(config.props["color"] as? Long ?: 0xFF000000),
                fontSize = (config.props["fontSize"] as? Number)?.toInt()?.sp ?: 14.sp
            )
            
            "button" -> UnifyButton(
                onClick = { handleAction(config.actions["onClick"]) },
                modifier = Modifier.padding(config.getMargin())
            ) {
                UnifyText(config.props["label"] as? String ?: "Button")
            }
            
            "image" -> UnifyImage(
                src = config.props["src"] as? String ?: "",
                contentDescription = config.props["alt"] as? String,
                modifier = Modifier.size(
                    width = (config.props["width"] as? Number)?.toInt()?.dp ?: 100.dp,
                    height = (config.props["height"] as? Number)?.toInt()?.dp ?: 100.dp
                )
            )
            
            "list" -> UnifyLazyColumn {
                val items = config.props["items"] as? List<Map<String, Any>> ?: emptyList()
                items(items.size) { index ->
                    val item = items[index]
                    RenderComponent(
                        ComponentConfig(
                            componentType = config.props["itemType"] as? String ?: "text",
                            props = item
                        )
                    )
                }
            }
        }
    }
    
    @Composable
    private fun RenderLayout(config: LayoutConfig) {
        when (config.layoutType) {
            "column" -> Column(
                modifier = Modifier.padding(config.getMargin()),
                verticalArrangement = config.getVerticalArrangement(),
                horizontalAlignment = config.getHorizontalAlignment()
            ) {
                config.children.forEach { child ->
                    RenderFromConfig(child)
                }
            }
            
            "row" -> Row(
                modifier = Modifier.padding(config.getMargin()),
                horizontalArrangement = config.getHorizontalArrangement(),
                verticalAlignment = config.getVerticalAlignment()
            ) {
                config.children.forEach { child ->
                    RenderFromConfig(child)
                }
            }
            
            "box" -> Box(
                modifier = Modifier.padding(config.getMargin())
            ) {
                config.children.forEach { child ->
                    RenderFromConfig(child)
                }
            }
        }
    }
    
    private fun handleAction(action: ActionConfig?) {
        when (action?.type) {
            "navigate" -> {
                val destination = action.params["destination"] as? String
                // 执行导航
            }
            "api_call" -> {
                val url = action.params["url"] as? String
                // 执行 API 调用
            }
            "show_toast" -> {
                val message = action.params["message"] as? String
                // 显示 Toast
            }
        }
    }
}

// 配置数据类
sealed class UIConfig {
    abstract val type: UIType
}

data class PageConfig(
    override val type: UIType = UIType.PAGE,
    val title: String,
    val components: List<ComponentConfig>
) : UIConfig()

data class ComponentConfig(
    override val type: UIType = UIType.COMPONENT,
    val componentType: String,
    val props: Map<String, Any> = emptyMap(),
    val actions: Map<String, ActionConfig> = emptyMap()
) : UIConfig()

data class LayoutConfig(
    override val type: UIType = UIType.LAYOUT,
    val layoutType: String,
    val props: Map<String, Any> = emptyMap(),
    val children: List<UIConfig> = emptyList()
) : UIConfig()

data class ActionConfig(
    val type: String,
    val params: Map<String, Any> = emptyMap()
)

enum class UIType {
    PAGE, COMPONENT, LAYOUT
}

// shared/commonMain/kotlin/ui/screens/product/ProductListScreen.kt
@Page("productList")
internal class ProductListPage : UnifyComposeContainer() {
    
    private lateinit var viewModel: ProductListViewModel
    
    override fun setupUnifyTheme() {
        // 设置商品页面主题
    }
    
    override fun initializeViewModel() {
        viewModel = koinInject()
    }
    
    override fun getViewModel(): BaseViewModel = viewModel
    
    @Composable
    override fun Content() {
        val uiState by viewModel.uiState.collectAsState()
        val navController = LocalUnifyNavController.current
        
        LaunchedEffect(Unit) {
            viewModel.handleIntent(ProductListIntent.LoadProducts)
        }
        
        ProductListScreen(
            uiState = uiState,
            onIntent = viewModel::handleIntent,
            onNavigateToDetail = { productId ->
                navController.navigate("productDetail/$productId")
            }
        )
    }
}

@Composable
fun ProductListScreen(
    uiState: ProductListUiState,
    onIntent: (ProductListIntent) -> Unit,
    onNavigateToDetail: (String) -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        // 搜索栏
        SearchBar(
            query = uiState.searchQuery,
            onQueryChange = { query ->
                onIntent(ProductListIntent.UpdateSearchQuery(query))
            },
            onSearch = {
                onIntent(ProductListIntent.SearchProducts)
            }
        )
        
        // 筛选栏
        FilterBar(
            selectedCategory = uiState.selectedCategory,
            categories = uiState.categories,
            onCategorySelected = { category ->
                onIntent(ProductListIntent.SelectCategory(category))
            }
        )
        
        // 商品列表
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            
            uiState.error != null -> {
                ErrorView(
                    error = uiState.error,
                    onRetry = {
                        onIntent(ProductListIntent.LoadProducts)
                    }
                )
            }
            
            else -> {
                ProductGrid(
                    products = uiState.products,
                    onProductClick = onNavigateToDetail,
                    onFavoriteClick = { productId ->
                        onIntent(ProductListIntent.ToggleFavorite(productId))
                    }
                )
            }
        }
    }
}

@Composable
private fun SearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    onSearch: () -> Unit
) {
    UnifyCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Row(
            modifier = Modifier.padding(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            UnifyInput(
                value = query,
                onValueChange = onQueryChange,
                placeholder = "搜索商品...",
                modifier = Modifier.weight(1f)
            )
            
            Spacer(modifier = Modifier.width(8.dp))
            
            UnifyButton(
                onClick = onSearch,
                modifier = Modifier.size(48.dp)
            ) {
                Icon(Icons.Default.Search, contentDescription = "搜索")
            }
        }
    }
}

@Composable
private fun ProductGrid(
    products: List<Product>,
    onProductClick: (String) -> Unit,
    onFavoriteClick: (String) -> Unit
) {
    UnifyLazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        items(
            count = products.size,
            key = { index -> products[index].id }
        ) { index ->
            val product = products[index]
            ProductCard(
                product = product,
                onClick = { onProductClick(product.id) },
                onFavoriteClick = { onFavoriteClick(product.id) }
            )
        }
    }
}

@Composable
private fun ProductCard(
    product: Product,
    onClick: () -> Unit,
    onFavoriteClick: () -> Unit
) {
    UnifyCard(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
    ) {
        Column {
            // 商品图片
            UnifyImage(
                src = product.imageUrl,
                contentDescription = product.name,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.Crop
            )
            
            // 商品信息
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.Top
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        UnifyText(
                            text = product.name,
                            style = MaterialTheme.typography.titleMedium,
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis
                        )
                        
                        Spacer(modifier = Modifier.height(4.dp))
                        
                        UnifyText(
                            text = "¥${product.price}",
                            style = MaterialTheme.typography.titleLarge,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                    
                    IconButton(
                        onClick = onFavoriteClick
                    ) {
                        Icon(
                            imageVector = if (product.isFavorite) {
                                Icons.Filled.Favorite
                            } else {
                                Icons.Default.FavoriteBorder
                            },
                            contentDescription = "收藏",
                            tint = if (product.isFavorite) {
                                Color.Red
                            } else {
                                MaterialTheme.colorScheme.onSurface
                            }
                        )
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // 评分和销量
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    repeat(5) { index ->
                        Icon(
                            imageVector = if (index < product.rating) {
                                Icons.Filled.Star
                            } else {
                                Icons.Default.StarBorder
                            },
                            contentDescription = null,
                            tint = Color(0xFFFFD700),
                            modifier = Modifier.size(16.dp)
                        )
                    }
                    
                    Spacer(modifier = Modifier.width(8.dp))
                    
                    UnifyText(
                        text = "已售${product.soldCount}件",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}
```

#### 6.1.2 ViewModel 完整实现

```kotlin
// shared/commonMain/kotlin/ui/screens/product/ProductListViewModel.kt
class ProductListViewModel(
    private val productRepository: ProductRepository,
    private val favoriteRepository: FavoriteRepository
) : BaseViewModel() {
    
    override fun createInitialState(): ProductListUiState = ProductListUiState()
    
    override fun handleIntent(intent: UiIntent) {
        when (intent) {
            is ProductListIntent.LoadProducts -> loadProducts()
            is ProductListIntent.SearchProducts -> searchProducts()
            is ProductListIntent.UpdateSearchQuery -> updateSearchQuery(intent.query)
            is ProductListIntent.SelectCategory -> selectCategory(intent.category)
            is ProductListIntent.ToggleFavorite -> toggleFavorite(intent.productId)
            is ProductListIntent.LoadMore -> loadMoreProducts()
        }
    }
    
    private fun loadProducts() {
        viewModelScope.launch {
            updateState { copy(isLoading = true, error = null) }
            
            try {
                val categories = productRepository.getCategories()
                val products = productRepository.getProducts(
                    category = uiState.value.selectedCategory,
                    query = uiState.value.searchQuery
                )
                
                updateState {
                    copy(
                        isLoading = false,
                        products = products,
                        categories = categories,
                        hasMore = products.size >= PAGE_SIZE
                    )
                }
            } catch (e: Exception) {
                updateState {
                    copy(
                        isLoading = false,
                        error = e.message ?: "加载失败"
                    )
                }
                sendEffect(ProductListEffect.ShowError("加载商品失败"))
            }
        }
    }
    
    private fun searchProducts() {
        if (uiState.value.searchQuery.isBlank()) {
            loadProducts()
            return
        }
        
        viewModelScope.launch {
            updateState { copy(isLoading = true) }
            
            try {
                val products = productRepository.searchProducts(
                    query = uiState.value.searchQuery,
                    category = uiState.value.selectedCategory
                )
                
                updateState {
                    copy(
                        isLoading = false,
                        products = products,
                        hasMore = products.size >= PAGE_SIZE
                    )
                }
            } catch (e: Exception) {
                updateState { copy(isLoading = false) }
                sendEffect(ProductListEffect.ShowError("搜索失败"))
            }
        }
    }
    
    private fun updateSearchQuery(query: String) {
        updateState { copy(searchQuery = query) }
    }
    
    private fun selectCategory(category: ProductCategory?) {
        updateState { copy(selectedCategory = category) }
        loadProducts()
    }
    
    private fun toggleFavorite(productId: String) {
        viewModelScope.launch {
            try {
                val product = uiState.value.products.find { it.id == productId }
                    ?: return@launch
                
                if (product.isFavorite) {
                    favoriteRepository.removeFavorite(productId)
                } else {
                    favoriteRepository.addFavorite(productId)
                }
                
                val updatedProducts = uiState.value.products.map { p ->
                    if (p.id == productId) {
                        p.copy(isFavorite = !p.isFavorite)
                    } else p
                }
                
                updateState { copy(products = updatedProducts) }
                
                sendEffect(
                    ProductListEffect.ShowSuccess(
                        if (product.isFavorite) "已取消收藏" else "已添加收藏"
                    )
                )
            } catch (e: Exception) {
                sendEffect(ProductListEffect.ShowError("操作失败"))
            }
        }
    }
    
    private fun loadMoreProducts() {
        if (uiState.value.isLoadingMore || !uiState.value.hasMore) return
        
        viewModelScope.launch {
            updateState { copy(isLoadingMore = true) }
            
            try {
                val moreProducts = productRepository.getProducts(
                    category = uiState.value.selectedCategory,
                    query = uiState.value.searchQuery,
                    offset = uiState.value.products.size
                )
                
                updateState {
                    copy(
                        isLoadingMore = false,
                        products = products + moreProducts,
                        hasMore = moreProducts.size >= PAGE_SIZE
                    )
                }
            } catch (e: Exception) {
                updateState { copy(isLoadingMore = false) }
                sendEffect(ProductListEffect.ShowError("加载更多失败"))
            }
        }
    }
    
    companion object {
        private const val PAGE_SIZE = 20
    }
}

data class ProductListUiState(
    val isLoading: Boolean = false,
    val isLoadingMore: Boolean = false,
    val products: List<Product> = emptyList(),
    val categories: List<ProductCategory> = emptyList(),
    val selectedCategory: ProductCategory? = null,
    val searchQuery: String = "",
    val error: String? = null,
    val hasMore: Boolean = true
) : UiState

sealed class ProductListIntent : UiIntent {
    object LoadProducts : ProductListIntent()
    object SearchProducts : ProductListIntent()
    object LoadMore : ProductListIntent()
    data class UpdateSearchQuery(val query: String) : ProductListIntent()
    data class SelectCategory(val category: ProductCategory?) : ProductListIntent()
    data class ToggleFavorite(val productId: String) : ProductListIntent()
}

sealed class ProductListEffect : UiEffect {
    data class ShowError(val message: String) : ProductListEffect()
    data class ShowSuccess(val message: String) : ProductListEffect()
    data class NavigateToDetail(val productId: String) : ProductListEffect()
}
```

### 6.2 数据层完整实现

#### 6.2.1 Repository 实现

```kotlin
// shared/commonMain/kotlin/data/repository/ProductRepositoryImpl.kt
class ProductRepositoryImpl(
    private val productApi: ProductApi,
    private val productDao: ProductDao,
    private val networkMonitor: NetworkMonitor
) : ProductRepository {
    
    override suspend fun getProducts(
        category: ProductCategory?,
        query: String?,
        offset: Int
    ): List<Product> {
        return if (networkMonitor.isOnline()) {
            try {
                val response = productApi.getProducts(
                    categoryId = category?.id,
                    query = query,
                    offset = offset,
                    limit = 20
                )
                
                // 缓存到本地数据库
                productDao.insertProducts(response.map { it.toEntity() })
                
                response.map { it.toDomain() }
            } catch (e: Exception) {
                // 网络失败时从本地加载
                productDao.getProducts(
                    categoryId = category?.id,
                    query = query,
                    offset = offset
                ).map { it.toDomain() }
            }
        } else {
            // 离线时从本地加载
            productDao.getProducts(
                categoryId = category?.id,
                query = query,
                offset = offset
            ).map { it.toDomain() }
        }
    }
    
    override suspend fun searchProducts(
        query: String,
        category: ProductCategory?
    ): List<Product> {
        return if (networkMonitor.isOnline()) {
            try {
                val response = productApi.searchProducts(
                    query = query,
                    categoryId = category?.id
                )
                response.map { it.toDomain() }
            } catch (e: Exception) {
                productDao.searchProducts(query).map { it.toDomain() }
            }
        } else {
            productDao.searchProducts(query).map { it.toDomain() }
        }
    }
    
    override suspend fun getCategories(): List<ProductCategory> {
        return if (networkMonitor.isOnline()) {
            try {
                val response = productApi.getCategories()
                
                // 缓存分类数据
                productDao.insertCategories(response.map { it.toEntity() })
                
                response.map { it.toDomain() }
            } catch (e: Exception) {
                productDao.getCategories().map { it.toDomain() }
            }
        } else {
            productDao.getCategories().map { it.toDomain() }
        }
    }
    
    override suspend fun getProductDetail(productId: String): Product? {
        return if (networkMonitor.isOnline()) {
            try {
                val response = productApi.getProductDetail(productId)
                
                // 更新本地缓存
                productDao.insertProduct(response.toEntity())
                
                response.toDomain()
            } catch (e: Exception) {
                productDao.getProduct(productId)?.toDomain()
            }
        } else {
            productDao.getProduct(productId)?.toDomain()
        }
    }
}
```

#### 6.2.2 网络 API 实现

```kotlin
// shared/commonMain/kotlin/data/remote/ProductApi.kt
interface ProductApi {
    suspend fun getProducts(
        categoryId: String? = null,
        query: String? = null,
        offset: Int = 0,
        limit: Int = 20
    ): List<ProductDto>
    
    suspend fun searchProducts(
        query: String,
        categoryId: String? = null
    ): List<ProductDto>
    
    suspend fun getCategories(): List<ProductCategoryDto>
    
    suspend fun getProductDetail(productId: String): ProductDto
}

class ProductApiImpl(
    private val httpClient: HttpClient
) : ProductApi {
    
    override suspend fun getProducts(
        categoryId: String?,
        query: String?,
        offset: Int,
        limit: Int
    ): List<ProductDto> {
        return httpClient.get("/api/products") {
            parameter("categoryId", categoryId)
            parameter("query", query)
            parameter("offset", offset)
            parameter("limit", limit)
        }.body()
    }
    
    override suspend fun searchProducts(
        query: String,
        categoryId: String?
    ): List<ProductDto> {
        return httpClient.get("/api/products/search") {
            parameter("q", query)
            parameter("categoryId", categoryId)
        }.body()
    }
    
    override suspend fun getCategories(): List<ProductCategoryDto> {
        return httpClient.get("/api/categories").body()
    }
    
    override suspend fun getProductDetail(productId: String): ProductDto {
        return httpClient.get("/api/products/$productId").body()
    }
}
```

### 6.3 最佳实践总结

#### 6.3.1 架构最佳实践

1. **分层架构**
   - UI 层：Compose 组件和 ViewModel
   - Domain 层：业务逻辑和用例
   - Data 层：数据源和仓库

2. **状态管理**
   - 使用 MVI 模式管理 UI 状态
   - 单一数据流，状态不可变
   - 通过 Intent 处理用户交互

3. **错误处理**
   - 统一的错误处理机制
   - 优雅的降级策略
   - 用户友好的错误提示

#### 6.3.2 性能最佳实践

1. **列表优化**
   - 使用 LazyColumn/LazyRow
   - 设置合适的 key
   - 实现分页加载

2. **图片加载**
   - 使用图片缓存
   - 支持占位符和错误图片
   - 按需加载和预加载

3. **内存管理**
   - 及时清理不需要的资源
   - 使用 LRU 缓存
   - 监控内存使用情况

#### 6.3.3 跨平台最佳实践

1. **平台适配**
   - 使用 expect/actual 处理平台差异
   - 保持 API 一致性
   - 针对平台特性优化

2. **组件设计**
   - 高内聚低耦合
   - 可复用和可测试
   - 遵循平台设计规范

3. **数据同步**
   - 支持离线模式
   - 数据一致性保证
   - 增量同步机制
- **团队学习成本**：提供充分的培训和文档

## 六、项目实施执行计划

### 6.1 实施阶段划分

#### 阶段一：基础架构搭建 (4-5周)
**目标**：建立 KMP 项目基础架构和核心模块

**主要任务**：
1. **项目初始化** (1周)
   - 创建 KMP 项目结构
   - 配置 Gradle 多平台构建脚本
   - 设置依赖管理和版本控制
   - 配置 CI/CD 流水线

2. **核心架构实现** (2周)
   - 实现 expect/actual 平台抽象层
   - 创建共享业务逻辑模块
   - 实现基础 ViewModel 和 Repository 架构
   - 设置状态管理和事件总线

3. **基础组件库** (1-2周)
   - 实现核心 Compose 组件 (Text, Button, Image, View)
   - 创建主题系统和样式管理
   - 实现基础布局组件 (Row, Column, Box)
   - 设置组件测试框架

**交付物**：
- 可编译的 KMP 项目架构
- 核心组件库 Demo
- 基础文档和开发指南

#### 阶段二：平台适配实现 (6-7周)
**目标**：完成各目标平台的适配和集成

**主要任务**：
1. **Android/iOS 平台** (2周)
   - 集成 Compose Multiplatform
   - 实现平台特定服务 (网络、存储、系统)
   - 适配平台 UI 规范和交互
   - 性能优化和测试

2. **HarmonyOS 平台** (2周)
   - 集成 KuiklyUI 框架
   - 配置 Kotlin/Native ohosArm64 目标
   - 实现 HarmonyOS 特定 API 适配
   - 测试和性能调优

3. **Web 平台** (1周)
   - 配置 Compose for Web
   - 实现 Kotlin/Wasm 构建
   - Web 特定优化和适配
   - 浏览器兼容性测试

4. **小程序平台** (1-2周)
   - 实现增强版桥接层
   - 微信小程序适配和测试
   - 支付宝小程序扩展
   - 其他小程序平台适配

**交付物**：
- 各平台可运行的 Demo 应用
- 平台适配文档
- 性能测试报告

#### 阶段三：业务功能迁移 (4-5周)
**目标**：将现有业务功能迁移到统御架构

**主要任务**：
1. **页面和路由** (1-2周)
   - 实现统一导航系统
   - 迁移现有页面结构
   - 参数传递和页面跳转
   - 深度链接支持

2. **业务组件迁移** (2周)
   - 复杂业务组件重构
   - 数据绑定和状态管理
   - 事件处理和生命周期
   - 动画和交互效果

3. **API 和数据层** (1-2周)
   - 网络请求层迁移
   - 数据模型和序列化
   - 缓存和持久化
   - 错误处理和重试机制

**交付物**：
- 功能完整的业务模块
- 数据迁移工具
- API 兼容性文档

#### 阶段四：测试和优化 (3-4周)
**目标**：全面测试、性能优化和问题修复

**主要任务**：
1. **功能测试** (1-2周)
   - 单元测试覆盖
   - 集成测试和 E2E 测试
   - 多平台兼容性测试
   - 用户验收测试

2. **性能优化** (1周)
   - 启动时间优化
   - 内存使用优化
   - 渲染性能调优
   - 包体积优化

3. **问题修复** (1周)
   - Bug 修复和稳定性提升
   - 用户体验优化
   - 安全性检查
   - 文档完善

**交付物**：
- 测试报告和覆盖率统计
- 性能基准测试结果
- 生产就绪的应用版本

#### 阶段五：上线和维护 (2-3周)
**目标**：生产环境部署和后续维护支持

**主要任务**：
1. **部署准备** (1周)
   - 生产环境配置
   - 发布流程和回滚机制
   - 监控和日志系统
   - 用户反馈收集

2. **灰度发布** (1周)
   - 小范围用户测试
   - 数据监控和分析
   - 问题快速响应
   - 逐步扩大发布范围

3. **维护支持** (1周)
   - 团队培训和知识转移
   - 维护文档和运营手册
   - 后续优化计划
   - 技术债务清理

**交付物**：
- 生产环境应用
- 运维文档和监控仪表板
- 团队培训材料

### 6.2 时间线和里程碑

```
Week 1-5:   阶段一 - 基础架构搭建
├─ Week 1:   项目初始化和环境配置
├─ Week 2-3: 核心架构和抽象层实现
└─ Week 4-5: 基础组件库开发

Week 6-12:  阶段二 - 平台适配实现
├─ Week 6-7:  Android/iOS 平台适配
├─ Week 8-9:  HarmonyOS 平台适配
├─ Week 10:   Web 平台适配
└─ Week 11-12: 小程序平台适配

Week 13-17: 阶段三 - 业务功能迁移
├─ Week 13-14: 页面和路由系统
├─ Week 15-16: 业务组件迁移
└─ Week 17:    API 和数据层迁移

Week 18-21: 阶段四 - 测试和优化
├─ Week 18-19: 功能测试和兼容性测试
├─ Week 20:    性能优化
└─ Week 21:    问题修复和稳定性提升

Week 22-24: 阶段五 - 上线和维护
├─ Week 22:    部署准备和环境配置
├─ Week 23:    灰度发布和监控
└─ Week 24:    维护支持和知识转移
```

### 6.3 资源配置和团队分工

#### 团队角色配置
- **项目经理** (1人): 项目协调、进度管理、风险控制
- **架构师** (1人): 技术架构设计、关键技术决策
- **Android 开发** (2人): Android 平台适配和优化
- **iOS 开发** (2人): iOS 平台适配和 Compose 集成
- **前端开发** (2人): Web 和小程序平台适配
- **HarmonyOS 开发** (1人): HarmonyOS 平台专项适配
- **测试工程师** (2人): 自动化测试、性能测试
- **DevOps 工程师** (1人): CI/CD、部署和监控

#### 关键技能要求
- **Kotlin Multiplatform** 开发经验
- **Compose Multiplatform** 实战经验
- **跨平台开发** 架构设计能力
- **性能优化** 和调试经验
- **自动化测试** 框架使用

### 6.4 风险管控和应对策略

#### 技术风险
1. **Compose Multiplatform 稳定性**
   - 风险：新技术可能存在未知问题
   - 应对：建立技术预研阶段，及时跟进官方更新

2. **小程序平台限制**
   - 风险：小程序平台 API 和性能限制
   - 应对：深度调研平台能力，设计降级方案

3. **HarmonyOS 生态成熟度**
   - 风险：HarmonyOS 开发工具链不够成熟
   - 应对：与华为技术团队建立沟通渠道

#### 项目风险
1. **进度延期**
   - 风险：复杂度超出预期导致延期
   - 应对：设置缓冲时间，采用敏捷开发模式

2. **人员变动**
   - 风险：关键人员离职影响项目进度
   - 应对：知识文档化，交叉培训

3. **需求变更**
   - 风险：业务需求频繁变更
   - 应对：建立变更控制流程，评估影响

### 6.5 质量保证措施

#### 代码质量
- **代码审查**：所有代码必须经过同行评审
- **静态分析**：集成 Detekt、KtLint 等工具
- **单元测试**：核心逻辑测试覆盖率 > 80%
- **文档规范**：API 文档和架构文档完整

#### 测试策略
- **单元测试**：共享逻辑层完整覆盖
- **集成测试**：平台间数据一致性验证
- **UI 测试**：关键用户路径自动化测试
- **性能测试**：启动时间、内存使用、渲染性能
- **兼容性测试**：多设备、多版本适配验证

#### 监控和反馈
- **实时监控**：应用性能和错误率监控
- **用户反馈**：建立用户反馈收集机制
- **数据分析**：用户行为和性能数据分析
- **持续改进**：基于数据驱动的优化决策

## 七、总结与展望

### 7.1 方案核心价值

**统御 (Unify)** 跨端架构方案基于 Kotlin Multiplatform 和 Compose 技术栈，为现代跨平台开发提供了完整的解决方案：

#### 技术价值
- **架构统一性**：通过 expect/actual 机制实现平台抽象，保持代码架构的一致性
- **性能优势**：各平台使用原生渲染引擎，性能媲美原生应用
- **开发效率**：共享业务逻辑减少重复开发，提升团队协作效率
- **维护成本**：统一的代码库降低长期维护成本和技术债务

#### 业务价值
- **快速迭代**：新功能可同时覆盖所有平台，缩短产品上线周期
- **一致体验**：统一的组件系统确保跨平台用户体验一致性
- **扩展能力**：模块化架构支持快速接入新平台和新功能
- **风险控制**：成熟的技术栈和完善的测试体系降低项目风险

### 7.2 技术创新点

1. **深度整合 KuiklyUI**：充分利用腾讯 KuiklyUI 的 HarmonyOS 适配能力
2. **增强小程序桥接**：创新的 JavaScript 桥接层实现小程序平台无缝集成
3. **统一组件体系**：基于 Compose 的跨平台组件库，保证 UI 一致性
4. **智能状态管理**：MVI 模式结合 Kotlin 协程的现代状态管理方案

### 7.3 实施保障

#### 分阶段实施策略
- **24 周完整计划**：从基础架构到生产上线的详细时间规划
- **风险可控**：每个阶段都有明确的交付物和验收标准
- **质量保证**：完善的测试策略和代码质量控制措施

#### 团队支持
- **技能培训**：提供 KMP 和 Compose 技术培训
- **文档完善**：详细的开发指南和最佳实践文档
- **持续支持**：建立技术支持和问题解决机制

### 7.4 未来展望

#### 技术演进方向
- **AI 集成**：探索 AI 辅助的跨平台开发工具
- **性能优化**：持续优化启动时间和运行时性能
- **新平台支持**：跟进新兴平台和技术趋势

#### 生态建设
- **开源贡献**：将通用组件和工具回馈开源社区
- **最佳实践**：建立跨平台开发的行业标准和规范
- **社区建设**：培养内部跨平台开发专家团队

统御方案不仅是一次技术架构的升级，更是面向未来的战略性技术投资。通过现代化的跨平台架构，为业务发展提供强有力的技术支撑，实现真正的"一套代码，统御全端"的技术愿景。
